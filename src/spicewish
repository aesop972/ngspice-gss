#!/bin/sh
# 22/6/04 -ad

# the next line starts SpiceWish interactively with the given file name  \
exec wish "$0" "$@"

package require spice
package require tclreadline
	
proc spicewish_usage { } {
	puts "usage: spicewish \[options ...\] \[inputfile ...\]"
	puts " -b        Run in batch mode."
	puts " -pp       Execute spicePP on given file."
	puts " -version  Display version number."
	puts ""
	exit
}
	
proc run_spicepp { fileName } {

	# load tcl code to run spicePP (perl)
	source [file join $::spice_library "spice/spicepp.tcl"]

	puts ""
	# check if file contains Hspice statements
	if {[spicepp::checkHSpiceFormat $fileName]} {

		set ppFileName  [spicepp::convert $fileName]
		if {$ppFileName == ""} {	
			puts "spicepp: Error translating file '$fileName'."
		       	exit
		}
		puts "spicewish: sourcing '$ppFileName'." 
		return $ppFileName
	} else {
		puts "spicepp: '$fileName' contains no Hspice statements."
		puts "spicewish: sourcing '$fileName'." 
		return $fileName
	}
}

proc spicewish_load { argv argc } { 
	set fileName ""
	set rawFileName ""
	set mode_batch 0
	set mode_spicePP 0

	for {set i 0} {$i < $argc} {incr i} {
		set arg [lindex $argv $i]

		if {[string match {-*} $arg]} {
			set val [lindex $argv [expr $i + 1]]
          
		      	switch -glob -- $arg {
			 	-- - -argv      {
				   	set argv [concat -- [lrange $argv $i end]]
		                  	set argc [llength $argv]
		               		break
	            		}
				-h - -help   { spicewish_usage }
		                -b           { set mode_batch 1 }
				-r 	     { set rawFileName $val; incr i}
				-version     { spice::version; exit }
		                -pp          { set mode_spicePP 1 }
				default { spicewish_usage }
		     	}
		} else {
		     	set fileName $arg
		}
	}

	if {$fileName == "" } { 
		spice_init_gui "" 0 $mode_batch $rawFileName
		return
	}

	if {![file isfile $fileName]} { spicewish_usage }

	if {$mode_spicePP} {
		set fileName [ run_spicepp $fileName ]
	}
		
	spice_init_gui $fileName 0 $mode_batch $rawFileName
}

proc Tclreadline { } {
	# readline with prompt set to "tclspice > "
	if {$::tcl_interactive} {
		proc ::tclreadline::prompt1 { } { return "tclspice -> " }
		
		puts "tclspice -> "
	
		if [info exists ::env(HOME)] {
	 	   set historyfile  $::env(HOME)/.tclspice-history
		} else {
		    set historyfile  .tclspice-history
		}

		::tclreadline::Loop $historyfile		
	}
}
	
	
proc spicewish_import_namespaces { } {


	#----------------
	# spice::
	# get list of spice:: commands
	set all_spiceCommands [namespace eval spice [list info commands]]
	set commands ""
	foreach command $all_spiceCommands {
		if {[namespace eval spice [list namespace origin $command]] == "::spice::${command}" } {
			lappend commands $command
		}
	}

	# export 	
	namespace eval spice [namespace export $commands]

	# import into current namespace
	namespace import -force spice::*
	
	# add command to readline
	foreach command $commands {
		::tclreadline::readline add $command
	}

	#----------------
	# spicewish::
	rename ::source ::tclSource
	rename ::load ::tclLoad
	
	namespace eval spicewish {
		set ::nameSpaceList [namespace export]
	}	

	namespace import -force spicewish::*
	
	foreach procName $::nameSpaceList {
		tclreadline::readline add ${procName}
	}

	rename spicewish_import_namespaces ""
}


set ::tcl_interactive 1
source [file join $::spice_library spice/spicewish.tcl]

spicewish_import_namespaces
spicewish_load $::argv $::argc

Tclreadline
