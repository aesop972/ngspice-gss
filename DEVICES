src/frontend/device.c:			ft_sim->devices[dg->dev_type_no]->name,
src/frontend/device.c:			ft_sim->devices[dg->dev_type_no]->description);
src/frontend/device.c:		if (ft_sim->devices[dg->dev_type_no]->numModelParms) {
src/frontend/device.c:	    } else if (ft_sim->devices[dg->dev_type_no]->numModelParms) {
src/frontend/device.c:			ft_sim->devices[dg->dev_type_no]->name,
src/frontend/device.c:			ft_sim->devices[dg->dev_type_no]->description);
src/frontend/device.c:	xcount = *ft_sim->devices[dg->dev_type_no]->numInstanceParms;
src/frontend/device.c:	plist = ft_sim->devices[dg->dev_type_no]->instanceParms;
src/frontend/device.c:	xcount = *ft_sim->devices[dg->dev_type_no]->numModelParms;
src/frontend/device.c:	plist = ft_sim->devices[dg->dev_type_no]->modelParms;
src/frontend/device.c:	xcount = *ft_sim->devices[dg->dev_type_no]->numInstanceParms;
src/frontend/device.c:	plist = ft_sim->devices[dg->dev_type_no]->instanceParms;
src/frontend/device.c:	xcount = *ft_sim->devices[dg->dev_type_no]->numModelParms;
src/frontend/device.c:	plist = ft_sim->devices[dg->dev_type_no]->modelParms;
src/frontend/device.c:	(*ft_sim->askInstanceQuest)(ft_curckt->ci_ckt, dg->instance,
src/frontend/device.c:	(*ft_sim->askModelQuest)(ft_curckt->ci_ckt, dg->model,
src/frontend/gens.c:				&& (ft_sim->devices[dg->dev_type_no]->flags
src/frontend/misccoms.c:    (void) sprintf(buf, SYSTEM_MAIL, ft_sim->simulator,
src/frontend/misccoms.c:	    ft_sim->version, Bug_Addr);
src/frontend/misccoms.c:	fprintf(cp_out, "** %s-%s : %s\n", ft_sim->simulator,
src/frontend/misccoms.c:		ft_sim->version, ft_sim->description);
src/frontend/misccoms.c:	    fprintf(cp_out, "** %s-%s\n", ft_sim->simulator,
src/frontend/misccoms.c:		    ft_sim->version);
src/frontend/misccoms.c:	    fprintf(cp_out, "** %s-%s : %s\n", ft_sim->simulator,
src/frontend/misccoms.c:		    ft_sim->version, ft_sim->description);
src/frontend/misccoms.c:	} else if (!eq(ft_sim->version, s)) {
src/frontend/misccoms.c:                    wl->wl_word, ft_sim->version);
src/frontend/misccoms.c:    printf("%s-%s done\n", ft_sim->simulator, ft_sim->version);
src/frontend/outitf.c:    fprintf(run->fp, "Command: version %s\n", ft_sim->version);
src/frontend/shyu.c:        err=(*(ft_sim->deleteTask))(ft_curckt->ci_ckt,
src/frontend/shyu.c:    err = (*(ft_sim->newTask))(ft_curckt->ci_ckt,
src/frontend/shyu.c:    for(j=0;j<ft_sim->numAnalyses;j++) {
src/frontend/shyu.c:        if(strcmp(ft_sim->analyses[j]->name,"options")==0) {
src/frontend/shyu.c:        err = (*(ft_sim->newAnalysis))(ft_curckt->ci_ckt,which,"options",
src/frontend/shyu.c:    for(j=0;j<ft_sim->numAnalyses;j++) {
src/frontend/shyu.c:        if(strcmp(ft_sim->analyses[j]->name,"SEN")==0) {
src/frontend/shyu.c:        err = (*(ft_sim->newAnalysis))(ft_curckt->ci_ckt,which,"sense",
src/frontend/shyu.c:        for(j=0;j<ft_sim->numAnalyses;j++) {
src/frontend/shyu.c:            if(strcmp(ft_sim->analyses[j]->name,"AC")==0) {
src/frontend/shyu.c:            err = (*(ft_sim->newAnalysis))(ft_curckt->ci_ckt,which,"acan",
src/frontend/shyu.c:        for(i=0;i<ft_sim->numAnalyses;i++) {
src/frontend/shyu.c:            if(strcmp(ft_sim->analyses[i]->name,"DCOP")==0) {
src/frontend/shyu.c:            err = (*(ft_sim->newAnalysis))(ft_curckt->ci_ckt,which,"dcop", 
src/frontend/shyu.c:        for(i=0;i<ft_sim->numAnalyses;i++) {
src/frontend/shyu.c:            if(strcmp(ft_sim->analyses[i]->name,"DCTransfer")==0) {
src/frontend/shyu.c:        err = (*(ft_sim->newAnalysis))(ft_curckt->ci_ckt,which,"DCtransfer", 
src/frontend/shyu.c:        for(j=0;j<ft_sim->numAnalyses;j++) {
src/frontend/shyu.c:            if(strcmp(ft_sim->analyses[j]->name,"TRAN")==0) {
src/frontend/shyu.c:            err = (*(ft_sim->newAnalysis))(ft_curckt->ci_ckt,which,"tranan",
src/frontend/shyu.c:        for(i=0;i<ft_sim->analyses[save]->numParms;i++) {
src/frontend/shyu.c:            ft_sim->analyses[save]->analysisParms[i].
src/frontend/shyu.c:                if(ft_sim->analyses[save]->analysisParms[i].
src/frontend/shyu.c:                    error = (*(ft_sim->setAnalysisParm))(ckt,
src/frontend/shyu.c:                        senseJob, ft_sim->analyses[save]->
src/frontend/shyu.c:                    parm = INPgetValue(ckt,&line,ft_sim->
src/frontend/shyu.c:                    error = (*(ft_sim->setAnalysisParm))(ckt,
src/frontend/shyu.c:                        senseJob, ft_sim->analyses[save]->
src/frontend/shyu.c:        if(i==ft_sim->analyses[save]->numParms) {
src/frontend/shyu.c:    if((err = (*(ft_sim->doAnalyses))(ckt, 1, ft_curckt->ci_curTask))!=OK){
src/frontend/spiceif.c:    err = (*(ft_sim->newCircuit))(&ckt);
src/frontend/spiceif.c:     (*(ft_sim->newTask))(ckt,(void**)&(ft_curckt->ci_defTask),taskUid);
src/frontend/spiceif.c:       (*(ft_sim->newTask))(ckt,(void**)&(ft_curckt->ci_defTask),taskUid,
src/frontend/spiceif.c:    for(j=0;j<ft_sim->numAnalyses;j++) {
src/frontend/spiceif.c:        if(strcmp(ft_sim->analyses[j]->name,"options")==0) {
src/frontend/spiceif.c:        err = (*(ft_sim->newAnalysis))(ft_curckt->ci_ckt,which,optUid,
src/frontend/spiceif.c:            (INPtables *) *tab,ft_curckt->ci_defTask, ft_sim->nodeParms,
src/frontend/spiceif.c:	    ft_sim->numNodeParms);
src/frontend/spiceif.c:            err=(*(ft_sim->deleteTask))(ft_curckt->ci_ckt,
src/frontend/spiceif.c:        err = (*(ft_sim->newTask))(ft_curckt->ci_ckt, 
src/frontend/spiceif.c:        err = (*(ft_sim->newTask))(ft_curckt->ci_ckt, 
src/frontend/spiceif.c:        for(j=0;j<ft_sim->numAnalyses;j++) {
src/frontend/spiceif.c:            if(strcmp(ft_sim->analyses[j]->name,"options")==0) {
src/frontend/spiceif.c:            err = (*(ft_sim->newAnalysis))(ft_curckt->ci_ckt,which,optUid,
src/frontend/spiceif.c:        if ((err = (*(ft_sim->doAnalyses))(ckt, 1, ft_curckt->ci_curTask))!=OK){
src/frontend/spiceif.c:        if ((err = (*(ft_sim->doAnalyses))(ckt, 0, ft_curckt->ci_curTask))!=OK){
src/frontend/spiceif.c:    for(i=0;i<ft_sim->numAnalyses;i++) {
src/frontend/spiceif.c:        if(strcmp(ft_sim->analyses[i]->name,"options")==0) {
src/frontend/spiceif.c:    for (i = 0; i < ft_sim->analyses[which]->numParms; i++)
src/frontend/spiceif.c:        if (eq(ft_sim->analyses[which]->analysisParms[i].keyword, name) &&
src/frontend/spiceif.c:                (ft_sim->analyses[which]->analysisParms[i].dataType & IF_SET))
src/frontend/spiceif.c:    if (i == ft_sim->analyses[which]->numParms) {
src/frontend/spiceif.c:    switch (ft_sim->analyses[which]->analysisParms[i].dataType & IF_VARTYPES) {
src/frontend/spiceif.c:                    ft_sim->analyses[which]->analysisParms[i].dataType);
src/frontend/spiceif.c:     if ((err = (*(ft_sim->setAnalysisParm))(cc, (void *)ft_curckt->ci_curOpt,
src/frontend/spiceif.c:             ft_sim->analyses[which]->analysisParms[i].id, &pval,
src/frontend/spiceif.c:     if ((err = (*(ft_sim->setAnalysisParm))(cc, (void *)ft_curckt->ci_defOpt,
src/frontend/spiceif.c:             ft_sim->analyses[which]->analysisParms[i].id, &pval,
src/frontend/spiceif.c:    switch(ft_sim->analyses[which]->analysisParms[i].dataType & IF_VARTYPES) {
src/frontend/spiceif.c:    (*(ft_sim->deleteCircuit))(cc);
src/frontend/spiceif.c:        device = ft_sim->devices[typecode];
src/frontend/spiceif.c:        device = ft_sim->devices[typecode];
src/frontend/spiceif.c:    device = ft_sim->devices[typecode];
src/frontend/spiceif.c:        err = (*(ft_sim->askInstanceQuest))((void *)ckt, (void *)dev, 
src/frontend/spiceif.c:        err = (*(ft_sim->askModelQuest))((void*)ckt, (void *) mod, 
src/frontend/spiceif.c:        err = (*(ft_sim->setInstanceParm))((void *)ckt, (void *)dev, 
src/frontend/spiceif.c:        err = (*(ft_sim->setModelParm))((void*)ckt, (void *) mod, 
src/frontend/spiceif.c:    err = (*(ft_sim->findInstance))((void *)ck,&type,devptr,name,NULL,NULL);
src/frontend/spiceif.c:    err = (*(ft_sim->findModel))((void *)ck,&type,modptr,name);
src/frontend/spiceif.c:    for(i=0;i<ft_sim->analyses[which]->numParms;i++) {
src/frontend/spiceif.c:        if(strcmp(ft_sim->analyses[which]->analysisParms[i].keyword,name)==0) {
src/frontend/spiceif.c:            return( (*(ft_sim->askAnalysisQuest))(ckt,anal,
src/frontend/spiceif.c:                    ft_sim->analyses[which]->analysisParms[i].id,parm,
src/frontend/spiceif.c:    for(i=0;i<ft_sim->numAnalyses;i++) {
src/frontend/spiceif.c:        if(strcmp(ft_sim->analyses[i]->name,"TRAN")==0){
src/frontend/spiceif.c:    err =(*(ft_sim->findAnalysis))(ci->ci_ckt,&which, &anal,tranUid,
src/frontend/spiceif.c:    for(i=0;i<ft_sim->numAnalyses;i++) {
src/frontend/spiceif.c:        if(strcmp(ft_sim->analyses[i]->name,"options")==0) {
src/frontend/spiceif.c:        for (i = 0; i < ft_sim->analyses[which]->numParms; i++)
src/frontend/spiceif.c:            if (eq(ft_sim->analyses[which]->analysisParms[i].keyword, name))
src/frontend/spiceif.c:        if (i == ft_sim->analyses[which]->numParms)
src/frontend/spiceif.c:        if ((*(ft_sim->askAnalysisQuest))(ckt, ft_curckt->ci_curTask,
src/frontend/spiceif.c:                ft_sim->analyses[which]->analysisParms[i].id, &parm, 
src/frontend/spiceif.c:        return (parmtovar(&parm, &(ft_sim->analyses[which]->analysisParms[i])));
src/frontend/spiceif.c:        for (i = 0, vars = v = NULL; i<ft_sim->analyses[which]->numParms; i++) {
src/frontend/spiceif.c:            if(!(ft_sim->analyses[which]->analysisParms[i].dataType&IF_ASK)) {
src/frontend/spiceif.c:            if ((*(ft_sim->askAnalysisQuest))(ckt, ft_curckt->ci_curTask, 
src/frontend/spiceif.c:                    ft_sim->analyses[which]->analysisParms[i].id, 
src/frontend/spiceif.c:                        &(ft_sim->analyses[which]->analysisParms[i]));
src/frontend/spiceif.c:                        &(ft_sim->analyses[which]->analysisParms[i])); 
src/frontend/where.c:	msg = (*ft_sim->nonconvErr)((void *) (ft_curckt->ci_ckt), 0);
src/frontend/where.c:	    msg = (*ft_sim->nonconvErr)((void *) (ft_curckt->ci_ckt), 0);
src/include/inpmacs.h:error=(*(ft_sim->func))args;\
src/main.c:    cp_program = ft_sim->simulator;
src/spicelib/devices/dev.c: * ft_sim->numDevices = num_devices();
src/spicelib/devices/dev.c:  ft_sim->numDevices = DEVNUM;
src/spicelib/devices/dev.c:  ft_sim->devices = devices_ptr();
src/spicelib/parser/inp2dot.c:    for (i = 0; i < ft_sim->numAnalyses; i++) {
src/spicelib/parser/inp2dot.c:	if (strcmp(ft_sim->analyses[i]->name, "NOISE") == 0) {
src/spicelib/parser/inp2dot.c:    for (i = 0; i < ft_sim->numAnalyses; i++) {
src/spicelib/parser/inp2dot.c:	if (strcmp(ft_sim->analyses[i]->name, "OP") == 0) {
src/spicelib/parser/inp2dot.c:    for (i = 0; i < ft_sim->numAnalyses; i++) {
src/spicelib/parser/inp2dot.c:	if (strcmp(ft_sim->analyses[i]->name, "DISTO") == 0) {
src/spicelib/parser/inp2dot.c:    for (i = 0; i < ft_sim->numAnalyses; i++) {
src/spicelib/parser/inp2dot.c:	if (strcmp(ft_sim->analyses[i]->name, "AC") == 0) {
src/spicelib/parser/inp2dot.c:    for (i = 0; i < ft_sim->numAnalyses; i++) {
src/spicelib/parser/inp2dot.c:	if (strcmp(ft_sim->analyses[i]->name, "PZ") == 0) {
src/spicelib/parser/inp2dot.c:    for (i = 0; i < ft_sim->numAnalyses; i++) {
src/spicelib/parser/inp2dot.c:	if (strcmp(ft_sim->analyses[i]->name, "DC") == 0) {
src/spicelib/parser/inp2dot.c:    for (i = 0; i < ft_sim->numAnalyses; i++) {
src/spicelib/parser/inp2dot.c:	if (strcmp(ft_sim->analyses[i]->name, "TF") == 0) {
src/spicelib/parser/inp2dot.c:    for (i = 0; i < ft_sim->numAnalyses; i++) {
src/spicelib/parser/inp2dot.c:	if (strcmp(ft_sim->analyses[i]->name, "TRAN") == 0) {
src/spicelib/parser/inp2dot.c:    for (i = 0; i < ft_sim->numAnalyses; i++) {
src/spicelib/parser/inp2dot.c:	if (strcmp(ft_sim->analyses[i]->name, "SENS") == 0) {
src/spicelib/parser/inp2dot.c:    for (i = 0; i < ft_sim->numAnalyses; i++) {
src/spicelib/parser/inp2dot.c:	if (strcmp(ft_sim->analyses[i]->name, "SENS2") == 0) {
src/spicelib/parser/inp2dot.c:	for (i = 0; i < ft_sim->analyses[which]->numParms; i++) {
src/spicelib/parser/inp2dot.c:			    ft_sim->analyses[which]->analysisParms[i].keyword)) {
src/spicelib/parser/inp2dot.c:		if (ft_sim->analyses[which]->analysisParms[i].dataType & IF_FLAG) {
src/spicelib/parser/inp2dot.c:			(*(ft_sim->setAnalysisParm)) (ckt, foo,
src/spicelib/parser/inp2dot.c:						      ft_sim->analyses[which]->analysisParms[i].id,
src/spicelib/parser/inp2dot.c:				    ft_sim->analyses[which]->analysisParms[i].dataType, tab);
src/spicelib/parser/inp2dot.c:			(*(ft_sim->setAnalysisParm)) (ckt, foo,
src/spicelib/parser/inp2dot.c:						      ft_sim->
src/spicelib/parser/inp2dot.c:	if (i == ft_sim->analyses[which]->numParms) {
src/spicelib/parser/inpapnam.c:    if (parmname && ft_sim->analyses[type]) {
src/spicelib/parser/inpapnam.c:	for (i = 0; i < ft_sim->analyses[type]->numParms; i++)
src/spicelib/parser/inpapnam.c:		       ft_sim->analyses[type]->analysisParms[i].keyword) ==
src/spicelib/parser/inpapnam.c:		return (*(ft_sim->setAnalysisParm)) (ckt, analPtr,
src/spicelib/parser/inpapnam.c:						     ft_sim->
src/spicelib/parser/inpdoopt.c:    for(i=0;i<ft_sim->numAnalyses;i++) {
src/spicelib/parser/inpdoopt.c:        prm = ft_sim->analyses[i];
src/spicelib/parser/inpdoopt.c:                    error = (*(ft_sim->setAnalysisParm))(ckt,anal,
src/spicelib/parser/inpdpar.c:	for (i = 0; i < (*(*(ft_sim->devices)[dev]).numInstanceParms); i++) {
src/spicelib/parser/inpdpar.c:		       ((*(ft_sim->devices)[dev]).instanceParms[i].
src/spicelib/parser/inpdpar.c:				((*(ft_sim->devices)[dev]).
src/spicelib/parser/inpdpar.c:		error = (*(ft_sim->setInstanceParm)) (ckt, fast,
src/spicelib/parser/inpdpar.c:						      (*(ft_sim->devices)
src/spicelib/parser/inpdpar.c:	if (i == (*(*(ft_sim->devices)[dev]).numInstanceParms)) {
src/spicelib/parser/inpgmod.c:		error = (*(ft_sim->newModel)) (ckt, (modtmp)->INPmodType,
src/spicelib/parser/inpgmod.c:		    for (j = 0; j < (* (*(ft_sim->devices)[(modtmp)->INPmodType]).numModelParms); j++) {
src/spicelib/parser/inpgmod.c:			if (strcmp("cpl", ((*(ft_sim->devices) [ (modtmp)->INPmodType ]).modelParms[j].keyword)) == 0) {
src/spicelib/parser/inpgmod.c:		      if (strcmp(parm,((*(ft_sim->devices)[(modtmp)->INPmodType]).modelParms[j].keyword)) == 0) {
src/spicelib/parser/inpgmod.c:			val = INPgetValue(ckt, &line, ((* (ft_sim->devices)[(modtmp)->INPmodType]).modelParms[j].dataType), tab);
src/spicelib/parser/inpgmod.c:			error = (*(ft_sim->setModelParm)) (ckt, ((modtmp)->INPmodfast),
src/spicelib/parser/inpgmod.c:							   (* (ft_sim->devices)[(modtmp)->INPmodType]).modelParms[j].id,
src/spicelib/parser/inpgmod.c:				(*(ft_sim->devices)
src/spicelib/parser/inpgtitl.c:    error = (*(ft_sim->newCircuit)) (ckt);
src/spicelib/parser/inppname.c:    for (i = 0; i < (*(*(ft_sim->devices)[dev]).numInstanceParms); i++) {
src/spicelib/parser/inppname.c:		   ((*(ft_sim->devices)[dev]).instanceParms[i].keyword)) ==
src/spicelib/parser/inppname.c:		(*(ft_sim->setInstanceParm)) (ckt, fast,
src/spicelib/parser/inppname.c:					      (*(ft_sim->devices)[dev]).
src/spicelib/parser/inppname.c:    if (i == (*(*(ft_sim->devices)[dev]).numInstanceParms)) {
src/spicelib/parser/inpptree.c:    for (i = 0; i < ft_sim->numSpecSigs; i++)
src/spicelib/parser/inpptree.c:	if (!strcmp(ft_sim->specSigs[i], buf))
src/spicelib/parser/inpptree.c:    if (i < ft_sim->numSpecSigs) {
src/spicelib/parser/inpsymt.c:    error = (*(ft_sim->newNode)) (ckt, &t->t_node, *token);
src/spicelib/parser/inpsymt.c:    error = (*(ft_sim->groundNode)) (ckt, &t->t_node, *token);
src/spicelib/parser/inptyplk.c:    for (i = 0; i < ft_sim->numDevices; i++) {
src/spicelib/parser/inptyplk.c:      printf("In INPtypelook, checking model type = %s against existing model = %s, . . .\n", type, (*(ft_sim->devices)[i]).name ); 
src/spicelib/parser/inptyplk.c:	if ((ft_sim->devices)[i] && strcmp(type, (*(ft_sim->devices)[i]).name) == 0) {
src/xspice/mif/mifgetmod.c:                error = (*(ft_sim->newModel))( ckt,(modtmp)->INPmodType,
src/xspice/mif/mifgetmod.c:                    for(j=0;j<*((*(ft_sim->devices)[(modtmp)->INPmodType]).numModelParms); j++) {
src/xspice/mif/mifgetmod.c:                        if (strcmp(parm,((*(ft_sim->devices) [ (modtmp)->
src/xspice/mif/mifgetmod.c:                                    ((*(ft_sim->devices)[(modtmp)->
src/xspice/mif/mifgetmod.c:                            error = (*(ft_sim->setModelParm))(ckt,
src/xspice/mif/mifgetmod.c:                                    (*(ft_sim->devices)[(modtmp)->INPmodType ]).
src/xspice/mif/mifgetmod.c:                    if(j >= *((*(ft_sim->devices)[(modtmp)->INPmodType]).numModelParms))
